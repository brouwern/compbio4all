{
posi <- positions[i]
typei <- types[i]
found <- 0
while (found == 0)
{
for (j in (i+1):numpositions)
{
posj <- positions[j]
typej <- types[j]
posdiff <- posj - posi
posdiffmod3 <- posdiff %% 3
orflength <- posj - posi + 3 # Add in the length of the stop codon
if (typei == "atg" && (typej == "taa" || typej == "tag" || typej == "tga") && posdiffmod3 == 0)
{
# Check if we have already used the stop codon at posj+2 in an ORF
numorfs <- length(orfstops)
usedstop <- -1
if (numorfs == 0)
{
for (k in 1:numorfs)
{
orfstopk <- orfstops[k]
if (orfstopk == (posj + 2)) { usedstop <- 1 }
}
}
if (usedstop == -1)
{
orfstarts <- append(orfstarts, posi, after=length(orfstarts))
orfstops <- append(orfstops, posj+2, after=length(orfstops)) # Including the stop codon.
orflengths <- append(orflengths, orflength, after=length(orflengths))
}
found <- 1
break
}
if (j == numpositions) { found <- 1 }
}
}
}
}
# Sort the final ORFs by start position:
indices <- order(orfstarts)
orfstarts <- orfstarts[indices]
orfstops <- orfstops[indices]
# Make a plot showing the positions of ORFs in the input sequence:
# Draw a line at y=0 from 1 to the length of the sequence:
x <- c(1,nchar(sequence))
y <- c(0,0)
plot(x, y, ylim=c(0,3), type="l", axes=FALSE, xlab="Nucleotide", ylab="Reading frame", main="Predicted ORFs")
segments(1,1,nchar(sequence),1)
segments(1,2,nchar(sequence),2)
# Add the x-axis at y=0:
axis(1, pos=0)
# Add the y-axis labels:
text(0.9,0.5,"+1")
text(0.9,1.5,"+2")
text(0.9,2.5,"+3")
# Make a plot of the ORFs in the sequence:
numorfs <- length(orfstarts)
for (i in 1:numorfs)
{
orfstart <- orfstarts[i]
orfstop <- orfstops[i]
remainder <- (orfstart-1) %% 3
if    (remainder == 0) # +1 reading frame
{
rect(orfstart,0,orfstop,1,col="cyan",border="black")
}
else if (remainder == 1)
{
rect(orfstart,1,orfstop,2,col="cyan",border="black")
}
else if (remainder == 2)
{
rect(orfstart,2,orfstop,3,col="cyan",border="black")
}
}
}
findORFsinSeq <- function(sequence)
{
require(Biostrings)
# Make vectors "positions" and "types" containing information on the positions of ATGs in the sequence:
mylist <- findPotentialStartsAndStops(sequence)
positions <- mylist[[1]]
types <- mylist[[2]]
# Make vectors "orfstarts" and "orfstops" to store the predicted start and stop codons of ORFs
orfstarts <- numeric()
orfstops <- numeric()
# Make a vector "orflengths" to store the lengths of the ORFs
orflengths <- numeric()
# Print out the positions of ORFs in the sequence:
# Find the length of vector "positions"
numpositions <- length(positions)
# There must be at least one start codon and one stop codon to have an ORF.
if (numpositions >= 2)
{
for (i in 1:(numpositions-1))
{
posi <- positions[i]
typei <- types[i]
found <- 0
while (found == 0)
{
for (j in (i+1):numpositions)
{
posj  <- positions[j]
typej <- types[j]
posdiff <- posj - posi
posdiffmod3 <- posdiff %% 3
# Add in the length of the stop codon
orflength <- posj - posi + 3
if (typei == "atg" && (typej == "taa" || typej == "tag" || typej == "tga") && posdiffmod3 == 0)
{
# Check if we have already used the stop codon at posj+2 in an ORF
numorfs <- length(orfstops)
usedstop <- -1
if (numorfs == 0)
{
for (k in 1:numorfs)
{
orfstopk <- orfstops[k]
if (orfstopk == (posj + 2)) { usedstop <- 1 }
}
}
if (usedstop == -1)
{
orfstarts <- append(orfstarts, posi, after=length(orfstarts))
orfstops <- append(orfstops, posj+2, after=length(orfstops)) # Including the stop codon.
orflengths <- append(orflengths, orflength, after=length(orflengths))
}
found <- 1
break
}
if (j == numpositions) { found <- 1 }
}
}
}
}
# Sort the final ORFs by start position:
indices <- order(orfstarts)
orfstarts <- orfstarts[indices]
orfstops <- orfstops[indices]
# Find the lengths of the ORFs that we have
orflengths <- numeric()
numorfs <- length(orfstarts)
for (i in 1:numorfs)
{
orfstart <- orfstarts[i]
orfstop <- orfstops[i]
orflength <- orfstop - orfstart + 1
orflengths <- append(orflengths,orflength,after=length(orflengths))
}
mylist <- list(orfstarts, orfstops, orflengths)
return(mylist)
}
findORFsinSeq <- function(sequence)
{
require(Biostrings)
# Make vectors "positions" and "types" containing information on the positions of ATGs in the sequence:
mylist <- findPotentialStartsAndStops(sequence)
positions <- mylist[[1]]
types <- mylist[[2]]
# Make vectors "orfstarts" and "orfstops" to store the predicted start and stop codons of ORFs
orfstarts <- numeric()
orfstops <- numeric()
# Make a vector "orflengths" to store the lengths of the ORFs
orflengths <- numeric()
# Print out the positions of ORFs in the sequence:
# Find the length of vector "positions"
numpositions <- length(positions)
# There must be at least one start codon and one stop codon to have an ORF.
if (numpositions >= 2)
{
for (i in 1:(numpositions-1))
{
posi <- positions[i]
typei <- types[i]
found <- 0
while (found == 0)
{
for (j in (i+1):numpositions)
{
posj  <- positions[j]
typej <- types[j]
posdiff <- posj - posi
posdiffmod3 <- posdiff %% 3
# Add in the length of the stop codon
orflength <- posj - posi + 3
if (typei == "atg" && (typej == "taa" || typej == "tag" || typej == "tga") && posdiffmod3 == 0)
{
# Check if we have already used the stop codon at posj+2 in an ORF
numorfs <- length(orfstops)
usedstop <- -1
if (numorfs == 0)
{
for (k in 1:numorfs)
{
orfstopk <- orfstops[k]
if (orfstopk == (posj + 2)) { usedstop <- 1 }
}
}
if (usedstop == -1)
{
orfstarts <- append(orfstarts, posi, after=length(orfstarts))
orfstops <- append(orfstops, posj+2, after=length(orfstops)) # Including the stop codon.
orflengths <- append(orflengths, orflength, after=length(orflengths))
}
found <- 1
break
}
if (j == numpositions) { found <- 1 }
}
}
}
}
# Sort the final ORFs by start position:
indices <- order(orfstarts)
orfstarts <- orfstarts[indices]
orfstops <- orfstops[indices]
# Find the lengths of the ORFs that we have
orflengths <- numeric()
numorfs <- length(orfstarts)
for (i in 1:numorfs)
{
orfstart <- orfstarts[i]
orfstop <- orfstops[i]
orflength <- orfstop - orfstart + 1
orflengths <- append(orflengths,orflength,after=length(orflengths))
}
mylist <- list(orfstarts, orfstops, orflengths)
return(mylist)
}
library(compbio4all)
library(compbio4all)
plot.phylo
library(ap)
library(ape)
?plot.phylo
?IRanges
library(IRanges)
?axis
?rect
transitionmatrix
library(compbio4all)
library(compbio4all)
library(compbio4all)
dmshrm.blast.1 <- bio3d::blast.pdb(dmshrm.actin)
dmshrm <- c("MKMRNHKENGNGSEMGESTKSLAKMEPENNNKISVVSVSKLLLKDSNGANSRSSNSNASFSSASVAGSVQ
DDLPHHNSSSSQLGQQHGSSLDQCGLTQAGLEEYNNRSSSYYDQTAFHHQKQPSYAQSEGYHSYVSSSDS
TSATPFLDKLRQESDLLSRQSHHWSENDLSSVCSNSVAPSPIPLLARQSHSHSHSHAHSHSNSHGHSHGH
AHSASSSSSSNNNSNGSATNNNNNNSSESTSSTETLKWLGSMSDISEASHATGYSAISESVSSSQRIVHS
SRVPTPKRHHSESVLYLHNNEEQGDSSPTASNSSQMMISEEANGEESPPSVQPLRIQHRHSPSYPPVHTS
MVLHHFQQQQQQQQDYQHPSRHHTNQSTLSTQSSLLELASPTEKPRSLMGQSHSMGDLQQKNPHQNPMLG
RSAGQQHKSSISVTISSSEAVVTIAPQPPAGKPSKLQLSLGKSEALSCSTPNMGEQSPTNSIDSYRSNHR
LFPVSTYTEPVHSNTSQYVQHPKPQFSSGLHKSAKLPVITPAGATVQPTWHSVAERINDFERSQLGEPPK
FAYLEPTKTHRLSNPALKALQKNAVQSYVERQQQQQKEEQQLLRPHSQSYQACHVERKSLPNNLSPIMVG
LPTGSNSASTRDCSSPTPPPPPRRSGSLLPNLLRRSSSASDYAEFRELHQAQGQVKGPSIRNISNAEKIS
FNDCGMPPPPPPPRGRLAVPTRRTSSATEYAPMRDKLLLQQAAALAHQQHHPQQHRHAQPPHVPPERPPK
HPNLRVPSPELPPPPQSELDISYTFDEPLPPPPPPEVLQPRPPPSPNRRNCFAGASTRRTTYEAPPPTAI
VAAKVPPLVPKKPTSLQHKHLANGGGGSRKRPHHATPQPILENVASPVAPPPPLLPRARSTAHDNVIASN
LESNQQKRSNSKASYLPRQSLEKLNNTDPDHGIYKLTLTSNEDLVAHTKPSYGVTGKLPNNLPDVLPLGV
KLHQQPKLQPGSPNGDANVTLRYGSNNNLTGNSPTVAPPPYYGGGQRYSTPVLGQGYGKSSKPVTPQQYT
RSQSYDVKHTSAVTMPTMSQSHVDLKQAAHDLETTLEEVLPTATPTPTPTPTPTPPRLSPASSHSDCSLS
TSSLECTINPIATPIPKPEAHIFRAEVISTTLNTNPLTTPPKPAMNRQESLRENIEKITQLQSVLMSAHL
CDASLLGGYTTPLITSPTASFANEPLMTPPLPPSPPPPLEPEEEEEQEENDVHDKQPEIEELQLMQRSEL
VLMVNPKPSTTDMACQTDELEDRDTDLEAAREEHQTRTTLQPRQRQPIELDYEQMSRELVKLLPPGDKIA
DILTPKICKPTSQYVSNLYNPDVPLRLAKRDVGTSTLMRMKSITSSAEIRVVSVELQLAEPSEEPTNLIK
QKMDELIKHLNQKIVSLKREQQTISEECSANDRLGQDLFAKLAEKVRPSEASKFRTHVDAVGNITSLLLS
LSERLAQTESSLETRQQERGALESKRDLLYEQMEEAQRLKSDIERRGVSIAGLLAKNLSADMCADYDYFI
NMKAKLIADARDLAVRIKGSEEQLSSLSDALVQSDC")
dmshrm <- gsub("\n", "", dmshrm)
dmshrm.actin <- substr(dmshrm,
start = 445,
stop =920)
dmshrm.blast.1 <- bio3d::blast.pdb(dmshrm.actin)
dmshrm.blast.1
usethis::use_data(dmshrm_blast_1, overwrite = TRUE)
dmshrm_blast_1 <- bio3d::blast.pdb(dmshrm.actin)
usethis::use_data(dmshrm_blast_1, overwrite = TRUE)
dmshrm_blast_2 <- bio3d::blast.pdb(dmshrm.actin)
blastr
#' Execute BLAST from R.
#'
#' Code is modified from the blast.pdb() function of bio3d to allow different databases to be queried and the maximum number of hits to be changed.
#'
#' For more information see
#' General: https://ncbi.github.io/blast-cloud/dev/api.html
#' Databases: https://ncbi.github.io/blast-cloud/blastdb/available-blastdbs.html for
#'
#' @param seq Sequence as character string, eg "ACVPTY" or "ATCGGC"
#' @param program blastn, blastp, blastx, tblastn, tblastx
#' @param database Defaults to refseq_protein  Other options include nt (nucleotide), nr (non-redundant protein), refseq_rna (NCBI Transcript Reference Sequences	DNA), swissprot (Non-redundant UniProtKB/SwissProt sequences	Protein), pdbaa (PDB protein database), pdbnt (PDB nucleotide database)
#' @param time.out xxx
#' @param chain.single xxxx
#' @param maxhits Maximum number of hits to keep.  Passed to BLAST parameter HITLIST_SIZE
#'
#' @export
blastr <- function(seq,
program = "blastp",
database = "refseq_protein",
time.out = NULL,
chain.single = TRUE,
maxhits = 2000){
library(bio3d)
if (inherits(seq, "fasta")) {
if (is.matrix(seq$ali)) {
if (nrow(seq$ali) > 1)
warning("Multiple sequences detected - using only the first sequence in input object")
seq <- as.vector(seq$ali[1, ])
}
else {
seq <- as.vector(seq$ali)
}
}
if (bio3d::is.pdb(seq)) {
seq <- bio3d::pdbseq(seq)
}
if (!is.vector(seq)) {
stop("Input 'seq' should be a single sequence as a single or multi element character vector (as obtained from the pdbseq() function)")
}
seq <- paste(seq, collapse = "")
#if (!(database %in% c("pdb", "nr", "swissprot")))
# stop("Option database should be one of pdb, nr or swissprot")
urlput <- paste("https://blast.ncbi.nlm.nih.gov/Blast.cgi?CMD=Put&DATABASE=",
database, "&HITLIST_SIZE=",maxhits,"&",program,"=blastp&CLIENT=web&QUERY=",
paste(seq, collapse = ""), sep = "")
txt <- scan(urlput, what = "raw", sep = "\n",
quiet = TRUE)
rid <- sub("^.*RID = ", "", txt[grep("RID =",
txt)])
urlget <- paste("https://blast.ncbi.nlm.nih.gov/Blast.cgi?CMD=Get",
"&FORMAT_OBJECT=Alignment",
"&ALIGNMENT_VIEW=Tabular",
"&RESULTS_FILE=on",
"&FORMAT_TYPE=CSV",
"&ALIGNMENTS=2000",
"&RID=",
rid,
sep = "")
blast <- bio3d::get.blast(urlget, time.out = time.out, chain.single = chain.single)
return(blast)
}
dmshrm_blast_2 <- blastr(dmshrm.actin)
usethis::use_data(dmshrm_blast_2, overwrite = TRUE)
dmshrm_blast_1 <- bio3d::blast.pdb(dmshrm.actin)
dmshrm_blast_2 <- blastr(dmshrm.actin)
usethis::use_data(dmshrm_blast_1, overwrite = TRUE)
usethis::use_data(dmshrm_blast_2, overwrite = TRUE)
dmshrm_blast_1
dmshrm_blast_2
dmshrm_blast_2 <- blastr(dmshrm.actin)
usethis::use_data(dmshrm_blast_1, overwrite = TRUE)
usethis::use_data(dmshrm_blast_2, overwrite = TRUE)
#' Execute BLAST from R.
#'
#' Code is modified from the blast.pdb() function of bio3d to allow different databases to be queried and the maximum number of hits to be changed.
#'
#' For more information see
#' General: https://ncbi.github.io/blast-cloud/dev/api.html
#' Databases: https://ncbi.github.io/blast-cloud/blastdb/available-blastdbs.html for
#'
#' @param seq Sequence as character string, eg "ACVPTY" or "ATCGGC"
#' @param program blastn, blastp, blastx, tblastn, tblastx
#' @param database Defaults to refseq_protein  Other options include nt (nucleotide), nr (non-redundant protein), refseq_rna (NCBI Transcript Reference Sequences	DNA), swissprot (Non-redundant UniProtKB/SwissProt sequences	Protein), pdbaa (PDB protein database), pdbnt (PDB nucleotide database)
#' @param time.out xxx
#' @param chain.single xxxx
#' @param maxhits Maximum number of hits to keep.  Passed to BLAST parameter HITLIST_SIZE
#'
#' @export
blastr <- function(seq,
program = "blastp",
database = "refseq_protein",
time.out = NULL,
chain.single = TRUE,
maxhits = 2000){
library(bio3d)
if (inherits(seq, "fasta")) {
if (is.matrix(seq$ali)) {
if (nrow(seq$ali) > 1)
warning("Multiple sequences detected - using only the first sequence in input object")
seq <- as.vector(seq$ali[1, ])
}
else {
seq <- as.vector(seq$ali)
}
}
if (bio3d::is.pdb(seq)) {
seq <- bio3d::pdbseq(seq)
}
if (!is.vector(seq)) {
stop("Input 'seq' should be a single sequence as a single or multi element character vector (as obtained from the pdbseq() function)")
}
seq <- paste(seq, collapse = "")
#if (!(database %in% c("pdb", "nr", "swissprot")))
# stop("Option database should be one of pdb, nr or swissprot")
urlput <- paste("https://blast.ncbi.nlm.nih.gov/Blast.cgi?CMD=Put&DATABASE=",
database, "&HITLIST_SIZE=",maxhits,"&",program,"=blastp&CLIENT=web&QUERY=",
paste(seq, collapse = ""), sep = "")
txt <- scan(urlput, what = "raw", sep = "\n",
quiet = TRUE)
rid <- sub("^.*RID = ", "", txt[grep("RID =",
txt)])
urlget <- paste("https://blast.ncbi.nlm.nih.gov/Blast.cgi?CMD=Get",
"&FORMAT_OBJECT=Alignment",
"&ALIGNMENT_VIEW=Tabular",
"&RESULTS_FILE=on",
"&FORMAT_TYPE=CSV",
"&ALIGNMENTS=2000",
"&RID=",
rid,
sep = "")
blast <- bio3d::get.blast(urlget, time.out = time.out, chain.single = chain.single)
return(blast)
}
dmshrm <- c("MKMRNHKENGNGSEMGESTKSLAKMEPENNNKISVVSVSKLLLKDSNGANSRSSNSNASFSSASVAGSVQ
DDLPHHNSSSSQLGQQHGSSLDQCGLTQAGLEEYNNRSSSYYDQTAFHHQKQPSYAQSEGYHSYVSSSDS
TSATPFLDKLRQESDLLSRQSHHWSENDLSSVCSNSVAPSPIPLLARQSHSHSHSHAHSHSNSHGHSHGH
AHSASSSSSSNNNSNGSATNNNNNNSSESTSSTETLKWLGSMSDISEASHATGYSAISESVSSSQRIVHS
SRVPTPKRHHSESVLYLHNNEEQGDSSPTASNSSQMMISEEANGEESPPSVQPLRIQHRHSPSYPPVHTS
MVLHHFQQQQQQQQDYQHPSRHHTNQSTLSTQSSLLELASPTEKPRSLMGQSHSMGDLQQKNPHQNPMLG
RSAGQQHKSSISVTISSSEAVVTIAPQPPAGKPSKLQLSLGKSEALSCSTPNMGEQSPTNSIDSYRSNHR
LFPVSTYTEPVHSNTSQYVQHPKPQFSSGLHKSAKLPVITPAGATVQPTWHSVAERINDFERSQLGEPPK
FAYLEPTKTHRLSNPALKALQKNAVQSYVERQQQQQKEEQQLLRPHSQSYQACHVERKSLPNNLSPIMVG
LPTGSNSASTRDCSSPTPPPPPRRSGSLLPNLLRRSSSASDYAEFRELHQAQGQVKGPSIRNISNAEKIS
FNDCGMPPPPPPPRGRLAVPTRRTSSATEYAPMRDKLLLQQAAALAHQQHHPQQHRHAQPPHVPPERPPK
HPNLRVPSPELPPPPQSELDISYTFDEPLPPPPPPEVLQPRPPPSPNRRNCFAGASTRRTTYEAPPPTAI
VAAKVPPLVPKKPTSLQHKHLANGGGGSRKRPHHATPQPILENVASPVAPPPPLLPRARSTAHDNVIASN
LESNQQKRSNSKASYLPRQSLEKLNNTDPDHGIYKLTLTSNEDLVAHTKPSYGVTGKLPNNLPDVLPLGV
KLHQQPKLQPGSPNGDANVTLRYGSNNNLTGNSPTVAPPPYYGGGQRYSTPVLGQGYGKSSKPVTPQQYT
RSQSYDVKHTSAVTMPTMSQSHVDLKQAAHDLETTLEEVLPTATPTPTPTPTPTPPRLSPASSHSDCSLS
TSSLECTINPIATPIPKPEAHIFRAEVISTTLNTNPLTTPPKPAMNRQESLRENIEKITQLQSVLMSAHL
CDASLLGGYTTPLITSPTASFANEPLMTPPLPPSPPPPLEPEEEEEQEENDVHDKQPEIEELQLMQRSEL
VLMVNPKPSTTDMACQTDELEDRDTDLEAAREEHQTRTTLQPRQRQPIELDYEQMSRELVKLLPPGDKIA
DILTPKICKPTSQYVSNLYNPDVPLRLAKRDVGTSTLMRMKSITSSAEIRVVSVELQLAEPSEEPTNLIK
QKMDELIKHLNQKIVSLKREQQTISEECSANDRLGQDLFAKLAEKVRPSEASKFRTHVDAVGNITSLLLS
LSERLAQTESSLETRQQERGALESKRDLLYEQMEEAQRLKSDIERRGVSIAGLLAKNLSADMCADYDYFI
NMKAKLIADARDLAVRIKGSEEQLSSLSDALVQSDC")
dmshrm <- gsub("\n", "", dmshrm)
dmshrm.actin <- substr(dmshrm,
start = 445,
stop =920)
dmshrm_blast_2 <- blastr(dmshrm.actin)
#usethis::use_data(dmshrm_blast_1, overwrite = TRUE)
usethis::use_data(dmshrm_blast_2, overwrite = TRUE)
library("biomaRt") # Load the biomaRt package in R
listEnsemblGenomes()        # List all Ensembl genomes that can be queried
ensemblprotists <- useEnsemblGenomes("protists_mart")
listDatasets(ensemblprotists)
ensemblleishmania <- useDataset("lmajor_eg_gene",
mart=ensemblprotists)
usethis::use_data(ensemblleishmania, overwrite = TRUE)
leishmaniagenes <- getBM(attributes = c("ensembl_gene_id"),
mart=ensemblleishmania)
usethis::use_data(leishmaniagenes, overwrite = TRUE)
leishmaniagenes2 <- getBM(attributes = c("ensembl_gene_id", "gene_biotype"),
mart=ensemblleishmania)
usethis::use_data(leishmaniagenes2, overwrite = TRUE)
# p fal
ensemblpfalciparum <- useDataset("pfalciparum_eg_gene",mart=ensemblprotists)
usethis::use_data(ensemblpfalciparum, overwrite = TRUE)
pfalciparumgenes <- getBM(attributes = c("ensembl_gene_id", "gene_biotype"),
mart=ensemblpfalciparum)
usethis::use_data(pfalciparumgenes, overwrite = TRUE)
ensemblpfalciparum <- useDataset("pfalciparum_eg_gene",mart=ensemblprotists)
usethis::use_data(ensemblpfalciparum, overwrite = TRUE)
pfalciparumgenes <- getBM(attributes = c("ensembl_gene_id", "gene_biotype"),
mart=ensemblpfalciparum)
usethis::use_data(pfalciparumgenes, overwrite = TRUE)
library(compbio4all)
library(compbio4all)
library(compbio4all)
library(compbio4all)
library(compbio4all)
library(compbio4all)
library(compbio4all)
library(compbio4all)
?sample
library(compbio4all)
library(compbio4all)
?rect
seq
?seq
?sequence
sq
library(compbio4all)
library(compbio4all)
library(compbio4all)
library(compbio4all)
library(compbio4all)
?root
library(compbio4all)
?subject
library(compbio4all)
library(compbio4all)
?c2s
library(seqinr)
?c2s
?seqinr
find_start_stop_ORFs
library(compbio4all)
library(compbio4all)
pairwiseAlignment
library(Biostrings)
?pairwiseAlignment
?substring
?append
?pattern
?subject
?substring
?countPattern
library(compbio4all)
library(compbio4all)
