---
title: "Tutorial: Writing functions to calculate the number of phylogenetic trees - KEY"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Tutorial: Writing functions to calculate the number of phylogenetic trees - KEY}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, eval = T}
library(compbio4all)
```

## Introduction

Phylogenetics is one of the original fields of computational biology.  This is because as the number of taxa that need to be organized on a tree increases, the number of unique phylogenetic trees increases rapidly.

The following refers to **bifurcating** tree which always branch into two branches at each **node**.  There are the type of branches built for phylogenies. 

(Note: this topic is discussed on page 187-189 of Baum & Smith Tree Thinking.  They discuss it in the concept of **maximum parsimony** estimation of phylogenetic trees.)


## Number of rooted trees

The number of possible **roooted phylogenetic** trees is calculated using the equation below.

In text:
(2n-3)!/(2^(n-2))(n-2)!

Rendered:

$\frac{(2*n-3)!}{2^{n-2} * (n-2)!}$

This equation is occassionaly mis-printed (as I did in the part of this original assignment) so its worth being explicit:

The numerator is: (2n-3)!, where "!" is factorial
The denominator is: (2^n-2)*(n-2)!; the factorial is evaluated first.

So, for n = 3 taxa

  (2n-3)!/(2^(n-2))(n-2)!
= (2x3-3)!/(2^(3-2))x(3-2)!
= (6  -3)!/(2^(1))x(1)!
= (3)!/(2)x(1)!
= (1 x 2 x 3)/(2 x 1)
= 6 / 2
= 3

```{r}
n <- 3
numerator <- factorial(2*n - 3)

```


Note that this applies to all tree typologies.  For n = 3 species  the three typologies are

((Human, Chimp), Gorilla)
((Human, Gorilla), Chimp)
((Chimp, Gorilla), Human)

Since we are referring to unique typologies, order within a clade doesn't matter. Therfore, these two are identical typologies

((Human, Chimp), Gorilla)
((Chimp, Human), Gorilla)



## Number of rooted trees in R

In R we take factorials using the factorial() function
```{r}
factorial(3)
3*2*1

factorial(4)
4*3*2*1
```

We can re-write our text equation above as
factorial(2n-3)/(2^(n-2))*(factorial(n-2))

In R would be

FOr n = 3
```{r}
n<-3
factorial(2*n-3)/((2^(n-2))*factorial(n-2))
```

For n = 4
```{r}
n<-4
factorial(2*n-3)/((2^(n-2))*factorial(n-2))
```

All of the parentheses make this a bit nutty.  Let me write this out as a seperate numerator and denominator

```{r}
n <- 3
numerator   <- factorial(2*n-3)
denominator <- 2^(n-2)*factorial(n-2)
numerator/denominator
```


## R Function to calculate the number of trees

We can set up a function to encapsulate this matth.  We'll call the function tree_count().  It has just one argument, n, the number of taxa on the tree.  We'll set the default to be n = 3 taxa.

Note that in a previous version of this code us used print(); in ver simple cases this results in identical output but for real use we want return().

```{r}
tree_count <- function(n = 3){
  numerator   <- factorial(2*n-3)
  denominator <- 2^(n-2)*factorial(n-2)
  trees  <- numerator / denominator 
  return(trees)
}

           
```

Does the function work work?
```{r}
tree_count()
tree_count(n = 3)
tree_count(n = 4)
```

How rapidly does the num er of possible trees grow?
```{r}
tree_count(n = 3)
tree_count(n = 4)
tree_count(n = 5)
tree_count(n = 6)
```


When working on a function its also good to check your output against against a source with the correct results. Tables with the number of trees per taxa are in many books, and also available here: https://en.wikipedia.org/wiki/Phylogenetic_tree

This number grows very rapidly.  According to Bianconi et al (2012) https://www.tandfonline.com/doi/full/10.3109/03014460.2013.807878 there are 3.72*10^13 cells in the body (37,200,000,000,000, or 3.72e13)
```{r}
37200000000000
3.72e13
```

If we put 14 taxa on a tree there are this many possible trees
```{r}
tree_count(n = 14)
```

If we put 15 taxa on the tree
```{r}
tree_count(n = 15)
```


## Vectorized inputs to functions

One of R's most powerful features is that it works on vectors.  I want to make a plot of the the number of possible trees for 3 to 10 taxa.  I can make a vector any way I chose

```{r}
#typing out all numbers
n.taxa <- c(3,4,5,6,7,8,9,10)

# using seq with arguments spelled out
n.taxa <- seq(from = 3,to = 10,by = 1)

#using seq w/o arguments
n.taxa <- seq(3, 10, 1)

#shortcuts
n.taxa <- c(3:10)
n.taxa <- 3:10
```

I can then put the vector as an input into my function

```{r}
tree_count(n = n.taxa)
```

I can save this output to a vector
```{r}
n.trees <- tree_count(n = n.taxa)
```

And plot things

```{r}
plot(n.trees ~ n.taxa, type = "b")
```

## Adding conditional statements

The equation above is only valid for 2 or more taxa.  If we put in a lower number the result doesn't make sense

```{r}
tree_count(n = 0)
tree_count(n = 1)
```

Only when we put in 2 or more taxa does it work
```{r}
tree_count(n = 2)
tree_count(n = 3)
```

Additinally, we can input non-integers and get a result.
```{r}
tree_count(n = 3.5)
```


We can add a **conditional statement** so that if 0 or 1 are input then an warning is given.

```{r}
tree_count2 <- function(n = 3){
  
  # conditional statement with if(){...}
  ## the condition: if n < 2, 
  if(n < 2){
    
    # the result 
    warning("This function is only valid for 2 or more taxa.")
    
  }
  
  #do the math
  numerator   <- factorial(2*n-3)
  denominator <- 2^(n-2)*factorial(n-2)
  trees  <- numerator / denominator 
  
  #return the result
  return(trees)
}
```


Now we can test this

```{r}
tree_count2(n = 0)
tree_count2(n = 1)
```

## Adding multiple conditional statements

The tree_count2() function above is still throwing error messages because even though it doesn't work with n <2, and even though its now giving us a warning, its still dong the math.  We can add a second conditional statement around the math to remedy this.

```{r}
tree_count3 <- function(n = 3){
  
  # conditional statement with if(){...}
  ## the condition: if n < 2, 
  if(n < 2){
    
    # the result 
    warning("This function is only valid for 2 or more taxa.")
    
  }
  
  #do the math
  if(n > 2){
    numerator   <- factorial(2*n-3)
  denominator <- 2^(n-2)*factorial(n-2)
  trees  <- numerator / denominator 
  
  #return the result
  return(trees)
  }
  
}
```

NOw we just get the warning we wrote but nothing else
```{r}
tree_count3(0)
tree_count3(1)
```


## More on adding additional arguments

Perhaps we want provide the option of always printing the results in scientific notation.  We can add a "format" argument for this.  If the argument is set to "sci", "scientific" or "e", the function will change the options for how numbers are printed

```{r}
tree_count4 <- function(n = 3, format = "standard"){
  
  # check for valid number of trees
  if(n < 2){
    warning("This function is only valid for 2 or more taxa.")
  }
  numerator   <- factorial(2*n-3)
  denominator <- 2^(n-2)*factorial(n-2)
  trees  <- numerator / denominator 
  
  if(format %in% c("sci","scientific","e")){
    options(scipen = -2,digits = 3)
  }
  
  print(trees)
  options(scipen = 0,digits = 7)
}
```

Test this
```{r}
tree_count4(n = 10)
tree_count4(n = 10, format = "sci")
tree_count4(n = 10, format = "scientific")
tree_count4(n = 10, format = "e")
```

## Assignment: unrooted trees

We often don't root phylogenetic trees.  This reduces the number of possible trees and is described by the equation

Text (note: this had a typo in previous version of assignmen!)
(2n-5)!/(2^(n-3))(n-3)!

Rendered:

$\frac{(2*n-5)!}{2^{n-3} * (n-3)!}$


## Assignment part 1

Modify the equation used above to work for unrooted trees.  Call the function tree_count_unrooted() Compare your results to http://carrot.mcb.uconn.edu/mcb396_41/tree_number.html

You can use the simplest form of the function which doesn't have any additional argument, eg

```{r}
#NOTE: this is for a ROOTED TREE
## change math to be for UN-ROOTED TREE
## change name of function to t()ree_count_unrooted
tree_count_rooted <- function(n = 3){
  numerator   <- factorial(2*n-3)
  denominator <- 2^(n-2)*factorial(n-2)
  trees  <- numerator / denominator 
  return(trees)
}

#Always test!
tree_count_rooted(4)
```



### Part 1 answer

```{r}
tree_count_unrooted <- function(n = 3){
  numerator   <- factorial(2*n-5)
  denominator <- 2^(n-3)*factorial(n-3)
  trees  <- numerator / denominator 
  return(trees)
}
```

CHeck against
```{r}
tree_count_unrooted(n = 3)
tree_count_unrooted(n = 4)
tree_count_unrooted(n = 5)
```

Compare rooted and unrooted
```{r}
tree_count_unrooted(n = 5)
tree_count_rooted(n = 5)
```


## Assignment part 2

Create a function that will work for rooted OR unrooted trees.  Do this by adding an additional argument like

type = "rooted"

and conditional statements like

if(type == "rooted"){
 #do this
}

if(type == "unrooted"){
 #do something else
}


Again, you can use the simplest form of the argument.

(Note: there was a typo in the original version of this where there were missing quotation marks around "rooted" and "unrooted" eg "rooted, so if you copy and pasted the code - which is what I would've done! - it wouldn't have worked).

### Answer

here is one way this could be written.

```{r}
tree_count3 <- function(n = 3, 
                           type = "rooted"){
  
if(type == "rooted"){
  #run rooted vs. of the calculation
  numerator   <- factorial(2*n-3)
  denominator <- 2^(n-2)*factorial(n-2)
  trees  <- numerator / denominator 
  }

if(type == "unrooted"){
  #unrooted version of the equation
  numerator   <- factorial(2*n-5)
  denominator <- 2^(n-3)*factorial(n-3)
  trees  <- numerator / denominator 
  return(trees)
 }
  
return(trees)  

}
```

Check the answer

```{r}
tree_count3(n= 5, type = "rooted")
tree_count3(n= 5, type = "unrooted")
```

We can plot rooted vs unrooted

```{r}
n.taxa <- seq(3,9,1)
y.rooted <- tree_count3(n= n.taxa, type = "rooted")
y.unrooted <- tree_count3(n= n.taxa, type = "unrooted")

plot(y.rooted ~ n.taxa, type = "b")
points(y.unrooted ~ n.taxa, type = "b", col = 3, lty = 2)
```

