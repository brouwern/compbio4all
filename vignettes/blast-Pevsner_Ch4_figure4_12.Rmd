---
title: "Pevsner Chapter 3: BLAST Algorithm in R (kinda)"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Pevsner Chapter 3: BLAST Algorithm in R (kinda)}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, eval = T}
library(compbio4all)
```



## Introduction

This tutorial shows how to reproduce key initial steps in the BLAST algorithm that are represented in "Phase 1" of Figure 4.12 of Pevsner (page 139).  Refer to Pevsner 138-141 for full details.  This corresponds with the first two bullet points on page 138, (often called 1 = "Setup", 2 = "Scanning").

## Preliminaries

We need the Biostrings package and the **BLOSUM62 matrix**.  BLOSUM is an alignment scoring systems that was created using a different approach but has the same goal as PAM matrices.  BLOSUM62 is the **default matrix** for BLAST calcualtions.


```{r}
# What is Biostrings?
# Where is it located prior to running library()?
# What changes when I run library()?

library(Biostrings)

# The BLOSUM62 matrix is stored as an R object within Biostrings
## The data() function loads it into memory so it can be accessed.
data("BLOSUM62")

BLOSUM62
```


## Creating a vector of amino acids

R has a built-in list of all letters in the alphabet
```{r}
LETTERS
```

Not all letters have amino acids:
```{r}
LETTERS[c(2,10,15,21,24,26)]
```


I can make a vector of the indices of these letters which are amino acids.
```{r}
not.an.aa <- c(2,10,15,21,24,26)
```


I can then use **"negative indexing"** to remove letters that don't correspond to an amino acid.  Using negative indexing here is easier than the alternative.  
```{r}
# What would the alternative to negative indexing be?
aas <- LETTERS[-not.an.aa]
```

## Creating the master BLAST Word list

I want to make a list of ALL possible BLAST words.  I call this the **BLAST master word list**, though I made this term up.  How many BLAST words are possible?  

I can use a fancy R function expand.grid() to make this word list.  I don't expect you to know how to use this function.

```{r}
words.list.all <- expand.grid(let1 = aas,
                              let2 = aas,
                              let3 = aas,
                       stringsAsFactors = F)
```

What have I done here?

```{r}
head(words.list.all)
```


How many unique words are there?
```{r}

n.words <- nrow(words.list.all)

```




## Accessing query sequence

Pevsner uses the sequence of human beta globin subunit B as his **query sequence**.  The **accession number** is NP_000509.1 and its located at https://www.ncbi.nlm.nih.gov/protein/4504349

I can download this directly from NCBI using entrez_fetch()
```{r}
#you may have to install the rentrez package
## install.packates("rentrez")
# load library
library(rentrez)

#download sequence( this is also pasted below)
fasta.out <- entrez_fetch(db = "protein",    # ?
                        id = "NP_000509.1",  # ?
                        rettype = "fasta")   # ?


```


A **FASTA file** provides this sequence, which I'm putting into a vector.  If entrez_fetch() doesn't work for some reason I can copy and paste the fasta file from the web.


```{r}

hbb <- c("MVHLTPEEKSAVTALWGKVNVDEVGGEALGRLLVVYPWTQRFFESFGDLSTPDAVMGNPKVKAHGKKVLG
AFSDGLAHLDNLKGTFATLSELHCDKLHVDPENFRLLGNVLVCVLAHHFGKEFTPPVQAAYQKVVAGVAN
ALAHKYH")

nchar(hbb)

```


Remove the slash n with the **regular expression** gsub().
```{r}

hbb <- gsub("\n", "",  hbb)

```



I will split raw **character string** into a vector of characters with strsplit(), with each character occuping one slot in the vector.  (strsplit outputs a list for some reason, so I use unlist to make it into a vector)

```{r}
hbb.split.list <- strsplit(hbb,"")
is(hbb.split.list)

#raw output is list; convert to vector
hbb.split.vect <- unlist(hbb.split.list)

is(hbb.split.vect)
```

## Creating working word list from query sequence

Create the list of words in the gene.  The default for protein BLAST (blastp) is to use words with 3 letters. I therefore want to build up my working database of words from the first three amino acids (MVH) to the last 3 amnio acids (KYH).  Its easy for me to get the total number of amino acids with length(), but I need to do a little math (length(x)-2) to make my code stop at the last full word.

First some prep; I'll make a vector called length.working which tells me how many words I need to make.  This will be used within a for() loop to tell R how many iterations to do.
```{r}
# First, the Total length of hbb polypeptide
length.total <- length(hbb.split.vect)

# Second, the number of full 3-letter words
#to make the loop work I need to not go all the way to end
## this will make sense in a second
length.working <- length.total-2

```


I'll need a matrix to store my words extracted from the query sequence.
```{r}

word.matrix <- matrix(data = NA, 
                      nrow = length.working, 
                      ncol = 3)

```


Now I'll looping over the query sequence vector and grab 3 letters at a time and put them into a matrix.  Each word will take up one row in the matrix.

```{r}

for(i in 1:length.working){
  
  #get the letters
  ## get the first leter, which = i
  letter1 <- hbb.split.vect[i]
  
  ## get the 2nd letter, which = i+1
  ### this get the letter just down sequence from 
  ### the first letter
  letter2 <- hbb.split.vect[i+1]
  
  ## get the 3rd letter
  letter3 <- hbb.split.vect[i+2]
  
  # Put the 3 letters in a vector
  word.i.vect <- c(letter1,letter2,letter3)
  
    # Shortcut: this is cleaner
    #    word.i.vect <- hbb.split.vect[c(i, i+1, i+2)]
    
  # put the current word into a row of the storage matrix
  word.matrix[i ,] <- word.i.vect
  
}

```

Currently, each word extracted from the query occupies a row of the matrix.  The

```{r}
head(word.matrix)
```

The first row is "M" "V" "H", so the first words is "MVH"

I can check this again the original sequence; 1:3 extacts the first 3 elemtns of the matrix holding the hbb sequence

```{r}
hbb.split.vect[1:3]
```


I can compile these letters from the columns their in into the actual words, eg, go from "M" "V" "H" accross 3 columns to  "MVH"

First, a place to store things
```{r}
word.vector <- rep(NA, nrow(word.matrix))
```


Now I'll loop over each row of word.matrix and use the paste() command to take the letters from each column and put them together like a regular word.
```{r}
for(i in 1:nrow(word.matrix)){
  word.vector[i] <- paste(word.matrix[i,], sep = "", collapse = "")
}
```

Aside: this isn't a very R way to do this.  An R pro would use the apply() function to avoid writing a loop explicitly.
```{r}
word.vector <-apply(word.matrix,1,paste,sep = "", collapse = "")
```


Regardless, the result looks like this (just showing the first 10 words)
```{r}
word.vector[1:10]
```


Pevsner uses words 12 through in his example in figure 4.12 page 139, starting wtih "VTA"
```{r}
pevs.words <- c(12:20)
word.vector[pevs.words]
```

## Words overlap

BLAST words from a query sequence overlap.  The "A" in the first word "VTA" therefore shows up in
VTA
TAL
ALW


The following code just creates a matrix to illusate this this

First, a storage matrix
```{r}
overlap.matrix <- matrix(data = "", nrow = 20, ncol = 22)
```


A loop to set things up
```{r}
for(i in 1:20){
  overlap.matrix[i,c(i,i+1,i+2) ] <- word.matrix[i,]
}

#give it some names
colnames(overlap.matrix) <- hbb.split.vect[1:22]


```

The code below shows the words that are shown in Pevsner Figure 4.12, page 139.
```{r}
overlap.matrix[c(12:20), c(12:22)]
```



## Aside: word frequencies

Note that is it possible for the same BLAST word to appear in more than one place within a query sequence.  We can see if this occurs in our HBB gene.  The table() function allows us to count up the number of occurrences of each word.

```{r}

word.table <- table(word.vector)

```

The order() function lets us create an index based on the number of times each word occures
```{r}

i.order <- order(word.table,decreasing = T)

```

We can then display the words from most frequent to least frequent

```{r, eval = F}

word.table[i.order]

```

How many words occur more than once?


We can also get a quick sense of things with the hist() command
```{r, eval = F}
hist(word.table)
```


The plot command tries to make sense of things but it kind of goes crazy
```{r, eval = F}
plot(word.table, ylab = "")
```

This works a bit better
```{r, eval = F}
plot(word.table[i.order], ylab = "")
```

Challenge: what is this code doing:

```{r,eval = F}

plot(word.table[i.order[1:10]], ylab = "")
```


## Determing neighboring words

So far we've made

1. A list of ALL 8000 BLAST words
1. A list of all the words that occur in the HBB gene.

Now we want to score all of the words in the HBB gene versus all of the words in the master word list.  We'll then take the highest scoring words and create smaller working list of words that are biochemically similar.  Scoring is done using a matrix such as BLOSUM62.    

Following Pevsner, we will use the 15th word LWG as an example and scores its alignment with each of the 8000 words in the word list.

First, a vector holding out focal word.
```{r}
# Focal BLAST "word" from Figure 4.12, "Phase 1", Pevsner pg 139.
word.focal <- c("L","W","G")
```

Make a place to store the scores when we compare LWG to the entire master word list.  I"ll make the matrix, convert it to a dataframe and name the columns.
```{r}
word.scores <- matrix(NA, 
                      nrow = n.words, 
                      ncol = 3)

# convert to dataframe to make it easier to work with
word.scores <- data.frame(word.scores)

#assign column names
colnames(word.scores) <- c("scrL1","scrL2","scrL3")

```


We'll now loop through each word in the master word list (words.all) and score it with the BLOSUM62 matrix.


(To explore this loop line by line, you can set i to 1 and run the code below line by line)

```{r}
i <- 1
```


The loop is presented below.  Its not a clean as it could be, but this is partially so I can set it up for future, more general use.  As a challenge, can you spot lines of the code that could be taken out of the loop and run on their own?

```{r}
# For loop
# This loop goes through each row of the master word matrix words.all
# and does what with it?

for(i in 1:nrow(word.scores)){
  
  # word.focal has our focal word
  # I want to get each letter from the focal word so
  # I can compar it 1:1 with the letters
  # in the word list
  word.focal.letter1 <- word.focal[1]
  word.focal.letter2 <- word.focal[2]
  word.focal.letter3 <- word.focal[3]
  
  #getting something from words.list.all here...
  ## note that I'm just indexing by [i, 1], [i, 2], [i, 3]
  ## "i" is what is changing with each iteratio of the loop
  ## (so i starts as 1, does everything in the loop, then
  ##     i becomes 2, does everything in loop, then
  ##     i becomes 3, ... and so on up to ...)
  ## What is stored in words.list.all.letter1, words.list.all.letter2, words.list.all.letter3?
  words.list.all.letter1 <- words.list.all[i,1]
  words.list.all.letter2 <- words.list.all[i,2]
  words.list.all.letter3 <- words.list.all[i,3]
  
  # Again, word scores is a matrix to store data 
  # before I stated the loop
  # i takes on a different value with each iteration of the loop
  # what am I doing here?
  word.scores[i,1] <- BLOSUM62[word.focal.letter1, words.list.all.letter1]
  word.scores[i,2] <- BLOSUM62[word.focal.letter2, words.list.all.letter2]
  word.scores[i,3] <- BLOSUM62[word.focal.letter3, words.list.all.letter3]
}
```

The output looks like this.  Each row corresponds to an alignment between my one focal word from the query sequence ("L" "W" "G") and eac of the 8000 words in the master word list.
```{r}
head(word.scores)
```


Next, I loop over each row of scores and add them up and put them in a column for the total scores
```{r}
# a column to store the scores
word.scores$word.score <- NA

# the loop
for(i in 1:nrow(word.scores)){
  
  word.scores$word.score[i] <- sum(word.scores[i,c(1,2,3)])
}


```

Aside: what I just did is the opposite of how most R programmers would do it
 This is the R way of doing the above loop with sum() in is
```{r}
word.scores$word.score <- apply(word.scores[ c(1,2,3)], 1, sum)

```

What is the max score? How does this compare to Pevsner Figure 4.12
```{r}
max(word.scores$word.score)

```



To make things easier to look at, I'll compress the columns holding all the words of the master word list into a single character vector.  This is just to help me make a table that is easy to read.

```{r}
# an empty vector made with the rep() function
words.as.string <- rep(NA, n.words)

# loop over each word in the master word list
for(i in 1:nrow(word.scores)){
  
  words.as.string[i] <- paste(words.list.all[i, ], sep = "", collapse = "")
}
```

Aside: what I just did is the opposite of how most R programmers would do it
This is the R way of doing the above
```{r}
words.as.string <- apply(words.list.all, 1, paste0, collapse = "")

```


Now I'll use cbind() to put the vector of words I just made (words.as.string) togther with my matrix of scores.  This is just to make a handy table to see the output
```{r}
word.scores <- cbind(words.as.string,
                word.scores)

```

The result looks like this
```{r}
head(word.scores)
```

## Compare scores to cutoff "T"

What is the distribution of scores?  BLAST uses a cuttoff "T", which defaults to 11.

```{r, eval = F}
library(ggpubr)
gghistogram(data = word.scores,
            x = "word.score",
            xlab = "Word score",
            ylab = "Number of words") +
  geom_vline(xintercept = 11, color = "red")

```

I want just those above T.  To demonstate this I'm going to remake more of Figure 4.12

First, some housekeeping.  This code asures that the contents of "words.as.string" are in the format
that I want

```{r}
word.scores$words.as.string <- as.character(word.scores$words.as.string)

```

Next, I'll put things in order from highest to lowest score using order()
```{r}
i.order <- order(word.scores$word.score,decreasing = T)
word.scores.sorted <- word.scores[i.order, ]

```

I'll check using head()
```{r}
head(word.scores.sorted)
```


I want just those 11 or greater.  I'll use which() to locate them and then subset the matrix.
```{r}
i.11.or.more <- which(word.scores.sorted$word.score > 10)

word.scores.above.t <- word.scores.sorted[i.11.or.more, ]

```


Pevsner uses T = 11, and further subsets based on representive words. 

The words he uses are these 15
```{r}
fig.4.12.aa <- c("LWG","IWG","MWG","VWG","FWG",
                 "AWG","LWS","LWN","LWA","LYG",
                 "LFG","FWS","AWS","CWS","IWC")

```


I can use the which() and %in% commands to locate those words that occur in the vector fig.4.12.aa.  The %in% command is not a conventional R command and I do not expect you do know it.  (I'm doin this simply to replicate what Pevsner has, not because its part of the algorithm)

```{r}
i.fig.4.12.aa <- which(word.scores.sorted$words.as.string %in% fig.4.12.aa)
```

This should reproduce the gist of the scores in the top part of Figure 4.12:
```{r}
word.scores.sorted[i.fig.4.12.aa, ]
```

Note that Pevsner only shows 15 words.  There's actually 72 with a score of 11 or more.  For the typical BLAST search we'd expect about 50 high-scoring matches per word in the query.

```{r}
dim(word.scores.above.t)
```


Recall that this table represents just some high scoring words matched with just the 15th word of the sequence LWG.  These words consitutte a **neighborhood** of closely related words.  This process would have to be repeated for each word in the sequence!

If I wanted to, I could write set of **nested for loops** to loop over each word from the query and compare each word with a loop as above to the master word list.  As for our focal word LWG, each iteration of this process would produce a matrix of high-scoring words. Since there are 147 amino acides in our HBB query sequence, there will be 145 words, and therefore 145 matrices containing each query words neighborhood of high-scoring words!  I'd probably store this output in a **list**.

## Comparing the query sequence of HBB to the database

BLAST takes a query sequence and compares it against databases of sequences.  You can select the database you want, or even particualr genomes.  Regardless, BLAST takes words from the query sequence and compares them against many proteins and amino acids.  Essentially, BLAST takes each word of interest from the query sequencs, gets a sequence from a database (eg, a single protein) and checks that sequene for the presence of the word.  Then it repeats this for each word and each sequence.

I'll simulate BLAST searching a single protein for a single word.  In the code below Below is the sequence of protin, anillin, from Drosophila which were are intereted in for the neural defects lab.
I am going to see if any of the "neighboring" words above the threshold T from one word from my query sequence HBB occurs in this gene which I know is unrelated to HBB.

The meta data for Anillin is: 
sp|Q9V4P1|ANLN_DROME Anillin OS=Drosophila melanogaster OX=7227 GN=scra PE=1 SV=3

The sequence is:
```{r, echo  = F}
anillin <-c("MDPFTQHMLEKAEQRSRALGISNASKFPLVECSVPSSSATSASGGDAGVLAPRSRSPGGQ
SAASGGGKVVTLGKATLEASPAKPLRHYTAVNKENLDMGIEINITTDKPIGVQVEIQEQE
VTDDEEQAEGGALNPLLEAEPVNQPLARLRDTSRSRLQRMGALYSNTDDLSSPIHRTEGQ
FHVTTGEEEDCGNRSSRQPKQRLGKLAALADTINQWEDDTSHHEVHRLLEAPPPKPHLSS
RRAEKGPAPLPPKKDEVDEASRTKQLKWDPKVLSSLEAQGFQRRESSTIKHTYDYAKQEE
AAPASKVEDAVLTAKPPVPQKSTTVSQVAKNFASSAPAPKPAPAPAVSVKSGLVSGRAAL
FENKGTGGQSQGLRNQKDPCELSLKERMKLFETGNNKAMLPMAPIGSAPSITQIRAEEVK
QHLAAMHPVTAAAATTVVAATKPKQENKLRDKVAALVANAQSSAETRIKDIDRQRQEDMQ
IISNRFNKQKELFDNQPSDSSVAAQARPPAPAPSRVVRPMPPPPPPPIAALSPGLASSKR
RSPGDAPTTDEDSKRARKSHSDRLYPALSDLDSSGDNCCAAETASATDDSHQQDEEETES
CMDESDDQSQTEDSSAGMCNGSLGREIMSAVQRNEVEMQQQQTGKKTVRYADQDMYYDDS
SLNSSQVSAGIDDYLDEALVEDYGSTQDDQSDSGDEQNASRLSLGSKGTTASNSFSFRKN
PASICTPIEEHHEMEMDLQTPLLSGAQPVKSELSVNQDNDNLVTLVHTVSFYRRQQSANS
SNSTPVRKICREQQVMRSALAGDCHAKHRLEYDSPQQSDYVAAATDIADQTDEDDEEMQN
AREVNDASQAQDKIKKLLSEVCKQQQVIGQASQALNLCAATVEFSGSTESVEGERYLLLA
THRRQACLDEVQRLRVENSIRPVGAPKEKGLLTVKDITIPLRQEYVRKMASNNINGHHLV
CLLKYNEHVLATKTVPTMPGLLSVKFPDVLQLNNVYADFRITLEIYGMLAQRDQLPHELK
YHINLNKKGGIKTPKKKGGENRLVMPPVQSPAGPHVVRTPQLVQYGFAIFSLREIQRTTW
TLTQVLGVSPLEGVVHMKVNCELSVSVEYKGFLTMFEDISGFGAWHRRWCYLNGSVINYW
KYPDDEKRKTPMGSIDLNSCTSQKVTTAPRDICARLNTMLLECERPALETDQESLIIVPN
GRTTTVRHLLSADTKEEREEWCAYLNKALTLLRAWGTTH")
```

The most direct way to search this sequence from the NCBI database for the presence of words is to use a regular expression grepl(), which tells me if a search string occurs in the sequence or not.  I can then cycle through each of the scores above t from HBB and check if they occur in anillin.  This is not what BLAST does, though there are some underlying similarities between regular expressions and the computations BLAST actually does.

What I'm going to do is work through my list of word scores above t, in the object word.scores.above.t.  (Recall that this matrix is for just a single original word from the query sequence; this whole process will need to be repeated about 150 times!)  If a word from the matrix occuring in anillin, I record "hit" in a new column of the amtrix.

First, I need a place to but the "hit" where a word in HBB occurr in anillin.  I'll make a new column in my vector of top-scoring words:
```{r}
word.scores.above.t$hit <- NA
```


Now I am going to loop over each word in word.scores.above.t.  I will have grepl() scan the full sequence of anillin for the presence of the word.  If grepl90 finds a match it will store the value of TRUE.  Otherwise if will return FALSE.  If TRUE is returned, then I'll store the word "TRUE" in my date matrix.  If not, I'll skip to the next word.

(As always, I don't expect you to learn regular expressions in this class.  If ever needed, I will write the code; I might ask you in general what is going on though or what I might use a regular expression for).

Again, this will loop over each word in word.scores.above.t and search for it in anillin using grepl.  After I do the search with grepl(), I use an if() statement to screen if a hit occurred.
```{r}

for(i in 1:nrow(word.scores.above.t)){
  
  # Run the regular express
  word.i <- word.scores.above.t$words.as.string[i]
  
  hit.output.TF <- grepl(word.i, anillin)
  
  if(hit.output.TF == TRUE){
    
    word.scores.above.t$hit[i] <- hit.output.TF
    
  }

}
```



The only "hit" I get is for "AWG".

```{r}
head(word.scores.above.t)
```

What does this mean?  This means that for the word "LWG" in the gene HBB, the similar word "AWG" occurs in anillin just one time.  Moreover, no other words in the "neighborhood" of LWG occurs in Anillin.

Again, it should be noted, of course, that "LWG" is just one of dozens of words in HBB, so this process needs to be repeated many more times to see which other words in HBB - and their high scoring relatives - occur in anillin.  Then this needs to be repated for other genes in the database.

## What happens with a hit?

BLAST firs search a database sequence for all hits to a query sequence.  It then checks the distance between the hits.  If two hits occur within 40 amino acids of each other BLAST then buils a un-gapped pairwise alignment between the query sequence and the database sequence in question.  So, for our example above, we found one hit for AWG.  If BLAST found another hit within 40 BP of AWG, it would then build a local alignment from that second hit.




\pagebreak

## Another approach

What I've just done requires actively scanning a sequence every time a BLAST search is done.  Though I wasn't sure at first, I believe this is what BLAST does.  

The code below presents another way this problem could be approached by first creating a database of all the words in anillin.

The code below is un-annotated code. As an assignment, annotate by hand each line of the code with some note about what the code is doing.   I will collect these at the beginning of class and then we will discuss the code, so you may want to photocopy your assignment or take a picture.  I will likely call on people randomly to ask if they know what the code does.  If a line of code spans more than 1 line, make a note on each and every line (see below for example). You will probably need to run all of the preceding code and investigate the inputs and output to figure out what it does

Ideally you'll be able to figure out what the big picture of the R code is and how it does what was previously done with the regular expression grepl(), but its perfectly acceptable to make notes on basic things. I'll discuss a few of the initial lines here.

For example, the first line of code is 

```{r, eval = F}
anillin <- gsub("\n","", anillin)
```

You could annotate this by writing "anillin is a character string with the anillin sequence" or "gsub is a regular expression" or "/n is the newline character".  This would all be full credit.  Ideally - or at least eventually - you'll be able to read this line of code and write something like "replace newline characters using regular expression"

The second line of code is

```{r, eval = F}
anillin.split.list <- strsplit(anillin,"")
```


To figure this out you'll probably have to run the code and compare the anillin object to the  anillin.split.list object.  look at it visually or using is(), then put a note in about what the change is, what strsplit() does, etc

The third line of code is
```{r, eval = F}
anillin.split.vect <- unlist(anillin.split.list)
```


TODO: this added while exploring code; remove?
```{r, eval = F}
anillin.length.total <- length(anillin.split.vect)

```


This is trickier.  There are lists in R, and unlist() turns a list into a vector().
For a line like this
```{r, eval = F}
anillin.length.total <- anillin.length.total-2
```



Ideally you'll know *why* I'm doing it (hint: word lengths = 3).  However, if you don't know biologically or computationally why a step is occurring, you can just write basically what's happening (this is just a mathematical operation).
For a line of code that spans multiple lines, annotate each line.  For example:


```{r, eval = F}
anillin.word.matrix <- matrix(data = NA,
                              nrow = anillin.length.total,
                              ncol = 3)
```



make a note about "anillin.word.matrix <- matrix(data = NA, "
and another note about "nrow = anillin.length.total, "
and a third note about "ncol = 3)"


## The code


```{r}
# remove \n from anillin
anillin <- gsub("\n","", anillin) 

# split anillin character string up
anillin.split.list <- strsplit(anillin,"")

# convert from list to vector
## each amino acid is not in a separate slot of 
## the vector
anillin.split.vect <- unlist(anillin.split.list)

# total length of vector; number of amino acids
anillin.length.total <- length(anillin.split.vect)

# total number of words in sequence
## which is 2 less than number of amino acids
anillin.length.total <- anillin.length.total-2


# matrix store the data
## fill with NAs
## make the number of rows = the lenghth of anillin seq
## make number of columns = 3
anillin.word.matrix <- matrix(data = NA,  
                      nrow = anillin.length.total, 
                      ncol = 3)


# loop over each aa in anillin seq
for(i in 1:anillin.length.total){
  
  # grab letters from anillin is sets of 3s
  word.i.vect <- anillin.split.vect[c(i, i+1, i+2)]# what does c(i, i+1, i+2) do?
  
  #store each word in a row of the matrix
  anillin.word.matrix[i ,] <- word.i.vect
  
}


# make a vector to store the words of anillin
## (instead of being in columns they'll be in
## actual 3-latter words, eg AAA)
anillin.word.vector <- rep(NA, nrow(anillin.word.matrix))


# Loop over each possible word
## paste into a single word
for(i in 1:length(anillin.word.vector)){
  anillin.word.vector[i] <- paste(anillin.word.matrix[i,], sep = "", collapse = "")
}


# make a table of all the words to see
# which ones are most common
anillin.word.table <- table(anillin.word.vector)
 

# put words in order; most common word will be first
i.anillin.order <- order(anillin.word.table, decreasing = T)



```


```{r, eval = F}
# Look at the output of the tabulation
anillin.word.table[i.anillin.order]
```



```{r, eval = F}
# hisogram of talbe
## one word occurs six times!
hist(anillin.word.table)

# similar output: a plot
plot(anillin.word.table[i.anillin.order],ylab = "")


# jus tlook at the first 175 amino acids
plot(anillin.word.table[i.anillin.order[1:175]],ylab = "")
```





## Compare HBB words > T with anillin word database

Once I've worked up a set of words for anillin, I can use which() and %in% to see where the matches are.

```{r, eval = F}
# use which() to compare the high-scoring words in 
# from the query sequence
# against all the words that occur in anillin
# store that in i.match
i.match <- which(word.scores.above.t$words.as.string %in% anillin.word.vector)

# look at the match
word.scores.above.t[i.match, ]

```









