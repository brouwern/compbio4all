---
title: "Simulating molecular evolution"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Simulating molecular evolution}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, eval = T}
library(compbio4all)
```


## R Markdown

Human cytochrome C 

https://www.ncbi.nlm.nih.gov/gene/4512
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1698023/

```{r}
cyo <- c("ATGTTCGCCGACCGTTGACTATTCTCTACAAACCACAAAGACATTGGAACACTATACCTATTATTCGGCG
CATGAGCTGGAGTCCTAGGCACAGCTCTAAGCCTCCTTATTCGAGCCGAGCTGGGCCAGCCAGGCAACCT
TCTAGGTAACGACCACATCTACAACGTTATCGTCACAGCCCATGCATTTGTAATAATCTTCTTCATAGTA
ATACCCATCATAATCGGAGGCTTTGGCAACTGACTAGTTCCCCTAATAATCGGTGCCCCCGATATGGCGT
TTCCCCGCATAAACAACATAAGCTTCTGACTCTTACCTCCCTCTCTCCTACTCCTGCTCGCATCTGCTAT
AGTGGAGGCCGGAGCAGGAACAGGTTGAACAGTCTACCCTCCCTTAGCAGGGAACTACTCCCACCCTGGA
GCCTCCGTAGACCTAACCATCTTCTCCTTACACCTAGCAGGTGTCTCCTCTATCTTAGGGGCCATCAATT
TCATCACAACAATTATCAATATAAAACCCCCTGCCATAACCCAATACCAAACGCCCCTCTTCGTCTGATC
CGTCCTAATCACAGCAGTCCTACTTCTCCTATCTCTCCCAGTCCTAGCTGCTGGCATCACTATACTACTA
ACAGACCGCAACCTCAACACCACCTTCTTCGACCCCGCCGGAGGAGGAGACCCCATTCTATACCAACACC
TATTCTGATTTTTCGGTCACCCTGAAGTTTATATTCTTATCCTACCAGGCTTCGGAATAATCTCCCATAT
TGTAACTTACTACTCCGGAAAAAAAGAACCATTTGGATACATAGGTATGGTCTGAGCTATGATATCAATT
GGCTTCCTAGGGTTTATCGTGTGAGCACACCATATATTTACAGTAGGAATAGACGTAGACACACGAGCAT
ATTTCACCTCCGCTACCATAATCATCGCTATCCCCACCGGCGTCAAAGTATTTAGCTGACTCGCCACACT
CCACGGAAGCAATATGAAATGATCTGCTGCAGTGCTCTGAGCCCTAGGATTCATCTTTCTTTTCACCGTA
GGTGGCCTGACTGGCATTGTATTAGCAAACTCATCACTAGACATCGTACTACACGACACGTACTACGTTG
TAGCCCACTTCCACTATGTCCTATCAATAGGAGCTGTATTTGCCATCATAGGAGGCTTCATTCACTGATT
TCCCCTATTCTCAGGCTACACCCTAGACCAAACCTACGCCAAAATCCATTTCACTATCATATTCATCGGC
GTAAATCTAACTTTCTTCCCACAACACTTTCTCGGCCTATCCGGAATGCCCCGACGTTACTCGGACTACC
CCGATGCATACACCACATGAAACATCCTATCATCTGTAGGCTCATTCATTTCTCTAACAGCAGTAATATT
AATAATTTTCATGATTTGAGAAGCCTTCGCTTCGAAGCGAAAAGTCCTAATAGTAGAAGAACCCTCCATA
AACCTGGAGTGACTATATGGATGCCCCCCACCCTACCACACATTCGAAGAACCCGTATACATAAAATCTA
GA")
```

Use regular expression gsub() to remove the newline character 
```{r}
cyo <- gsub("\\n","",cyo)
```


Turn character string into vector using strsplit()
```{r}
cyo.vect.temp <- strsplit(cyo,"")
cyo.vect <- unlist(cyo.vect.temp)

table(cyo.vect)

```

Compare formats
```{r}
# original
is(cyo)
str(cyo)
cyo[1]

# after strin spli
is(cyo.vect.temp)
str(cyo.vect.temp)
cyo.vect.temp[1]

#final
is(cyo.vect)
str(cyo.vect)
cyo.vect[1]
cyo.vect[1:10]

```



## Simulate mutation at a single locus

Function to mutate a single base

Function has 3 arguments

* original; where we started

This will take on different values as we cycle through a sequence.  It has a default but normally will change as a loop progresses through a sequence.

* possible; what we can become

This could be set to amino acid

* probs; probility of each thing in "possible" happening

These have really high default values for illustration purposes.

```{r}
mutate_position <- function(original = "A",
                            possible = c("A","T","C","G"),
                            probs = c(1/3, 1/3, 1/3)){
  
  # First, if "original"is an NA, throw an erro
  if(is.na(original) == TRUE){
    warning("Thing to mutate is not listed in possible nucleotides or amino acids.  Check the data")
    print(original)
    browser()
  }

  # determine what the current thing to mutate is
  i.original <- which(possible == original)
  
  # remove the current status from the possible mutations
  possible.working <- possible[-i.original]
  
  # assign a new base
  new.base <- sample(x = possible.working, 
                size = 1, 
                prob = probs)
  
  return(new.base)
}

```


Test the function
```{r, eval = F}
mutate_position()
mutate_position(original = "A")
mutate_position(original = "T")
mutate_position(original = "C")
mutate_position(original = "G")
mutate_position(original = "")

```



## Function to mutate an entire sequence

This calls the function mutation_position()

```{r}
mutate_sequence <- function(u = 2e-01,
                            seq.t1 = cyo.vect){
  
  # length of sequence
  seq.len <- length(seq.t1)
  
  # create copy of seq to make changes to
  seq.t2 <- seq.t1
  
  # counter of total muatations
  tot.mutations <- 0
  
  # generate locations of mutations
  ## for each position, generate 0 or 1, with probablity of 1 = u
  ## returns a vector with 0 or 1 for each position
  mutated.positions <- rbinom(n = seq.len, # number of positions
                              size = 1,
                              prob = u)
  
  # apply mutations
  
  if(any(mutated.positions) == 1){
    mutation.locations <- which(mutated.positions == 1)
  
    for(j in mutation.locations){
     base.j <- seq.t1[j]
     
     if(is.na(base.j) == TRUE){
       browser()
     }
     
     if(is.character(base.j) == FALSE){
       browser()
     }
     
     new.base.j <- mutate_position(original = base.j)
      
     seq.t2[j] <- new.base.j
      
    # determine the total number of 
    tot.mutations <- sum(mutated.positions)
    }
  }
  
  # output
  output <- list(tot.mutations = tot.mutations,
                 seq.t1 = seq.t1,
                 seq.t2 = seq.t2 )
  
   return(output)
  
  }
 
    
```


Test the function 

```{r}
cyo.vect.short <- cyo.vect[1:25]

mutate_sequence(u = 0.05,seq.t1 = cyo.vect.short )

```


## Simulate evolution of 2 sequences

```{r}
diverge_two_sequences <- function(seq1,
                                  seq2,
                                  u = 2e-03,
                                  time = 1e4){
  
  # create data storage dataframe
  time.series <- data.frame(t = 1:time,
                            tot.mutations.s1 = NA,
                            tot.mutations.s2 = NA,
                            vis.mutations.s1 = NA,
                            vis.mutations.s2 = NA,
                            pairwise.diff = NA,
                            seq1 = NA,
                            seq2 = NA)
  
  # Store starting sequences (not implemented)
  # time.series[i, "seq1"] <- seq1
  # time.series[i, "seq2"] <- seq2
  
  # Save original sequence
  seq1.orig <- seq1
  seq2.orig <- seq2
  
  # set initial njmber of mutations to 0
  time.series[1,c("tot.mutations.s1","tot.mutations.s2")] <- 0
  time.series[1,c("vis.mutations.s1","vis.mutations.s2")] <- 0
    
  for(i in 2:time){
   # print(i)
    #mutate sequence 1
    ## run mutation function
    ### This function 1) mutates an input sequence 
    ###               2) compares mutated to input sequence
    ###               3) determines number of differences beteween
    ###                  input and mutated sequence
    seq1.output.i <- mutate_sequence(u = u, 
                                     seq.t1 = seq1)
    
    #mutate sequence 2
    seq2.output.i <- mutate_sequence(u = u, 
                                     seq.t1 = seq2)
    

    
    #determine cumulative number of mutations
    ## add up previous total of mutations to number that occurred
    ## during this time step.  
    ## This will include any back mutations since number of mutations
    ## is determined by compareing input vs. output sequence of seq1.output.x
    ## This is the TRUE genetic distance - ALL mutations of ANY kind
    time.series[i, "tot.mutations.s1"]<- time.series[i-1, "tot.mutations.s1"] +
                                         seq1.output.i$tot.mutations[1]
    
    time.series[i, "tot.mutations.s2"]<- time.series[i-1, "tot.mutations.s2"] +
                                         seq2.output.i$tot.mutations[1]
    
    # time.series[i+1, "seq1"] <- seq1.output.i$seq.t2[1]
    # time.series[i+1, "seq2"] <- seq2.output.i$seq.t2[1]
    
    # Divergence from original sequence
    ## Determine where in current sequence there are differrences
    ## with the original sequence
    seq1.delta <- which(seq1.orig != 
                        seq1.output.i$seq.t2)
    seq2.delta <- which(seq2.orig != 
                        seq2.output.i$seq.t2)
    
    
    # Count up number of differences with lenght()
    ## This is ONLY differeneces we'd see if we had access to the ancestral sequence
    ## A->T->A over 3 times steps = 0 mutations.
    if(any(seq1.delta > 0) == TRUE){
      time.series[i,c("vis.mutations.s1")] <- length(seq1.delta)
    }
    
    if(any(seq2.delta > 0) == TRUE){
      time.series[i,c("vis.mutations.s2")] <- length(seq2.delta)
    }
    
    
    seq1 <- seq1.output.i$seq.t2
    seq2 <- seq2.output.i$seq.t2
    
    pairwise.diff <- which(seq1.output.i$seq.t2!= 
                           seq2.output.i$seq.t2)
  
    time.series$pairwise.diff[i] <- length(pairwise.diff)
    
  }
  
  return(time.series)

}
```



### Simulate  Short time frame

```{r}
seq.length <- 25
cyo.vect.short <- cyo.vect[1:seq.length]
years <- 1000
x <- diverge_two_sequences(seq1 = cyo.vect.short,
                           seq2 = cyo.vect.short,
                                  u = 0.001,
                                  time = years)
```



### Plot

```{r}

### Plot Cumulative number of mutations


par(mfrow = c(2,2), 
    mar = c(4,4,3,0))

plot(tot.mutations.s1 ~ t, data = x,  type = "l", 
     #ylim = c(0, seq.length*1.01),
       main = "Cummulative number of mutations\n(inc. back mutations)",
       xlab = "Time",
       ylab = "Number of mutations")
points(tot.mutations.s2 ~ t, data = x, col = 2, type = "l")
abline(a = 0, b = 0.001*25)
abline(h = 25, lty = 2, col = 3)
legend("topleft",legend = c("seq1","seq2","Seq length"), lty = c(1,1,2), col = c(1,2,3))




### Divergence with ancestor

#If we could at least compare with the ancestral sequence.

# Divergence with ancestor can **decrease** due to **back mutations**


plot(vis.mutations.s1 ~ t, data = x,  type = "l", 
     ylim = c(0, seq.length*1.01),
       main = "Divergence with ancestor",
       xlab = "Time",
       ylab = "Divergence")
points(vis.mutations.s2 ~ t, data = x, col = 2, type = "l")
abline(a = 0, b = 0.001*25)
abline(h = 25, lty = 2, col = 3)
abline(h = 25*0.75, lty = 2, col = 1)





### Pairwise differences

plot(pairwise.diff ~ t, data = x,  type = "l", 
     ylim = c(0, seq.length*1.01),
       main = "Current pairwise differences",
       xlab = "Time",
       ylab = "pairwise.diff",
     lty = 1)
abline(a = 0, b = 0.001*25)
abline(h = 25*0.75, lty = 2, col = 3)




### Jukes Cantor Model


## JC distance function


jc <- function(p){
  K <- -3/4 * log(1 - 4/3*p)
  return(K)
}



##Add JC to plot


x$p <- x$pairwise.diff/seq.length
x$JC <- jc(x$p)  
x$JC.total <- x$JC*seq.length


x$distance.total <- x$tot.mutations.s1 + x$tot.mutations.s2

plot(distance.total/25 ~ t, data = x,  type = "l", 
    # ylim = c(0, seq.length*1.01),
    # main = "Cummulative number of mutations\n(inc. back mutations)",
       xlab = "Time",
       ylab = "Cumulative number of mutations"#,
  #  ylim = c(0,3)
    )
points(p ~ t, data = x, col = 2, type = "l")
points(JC ~ t, data = x, col = 3, type = "l")
legend("topleft",legend = c("Real dist","p dist","JC"), lty = c(1,1,2), col = c(1,2,3))

```










